// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user_center/auth/v2/auth.proto

package v2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	v2 "github.com/spark-comm/spark-api/api/common/enum/v2"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = v2.Gender(0)
)

// Validate checks the field values on AuthToken with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthToken with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthTokenMultiError, or nil
// if none found.
func (m *AuthToken) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for RefreshToken

	// no validation rules for ExpiresAt

	// no validation rules for RefExpiresAt

	// no validation rules for ServerCode

	// no validation rules for UserId

	// no validation rules for Options

	if len(errors) > 0 {
		return AuthTokenMultiError(errors)
	}

	return nil
}

// AuthTokenMultiError is an error wrapping multiple validation errors returned
// by AuthToken.ValidateAll() if the designated constraints aren't met.
type AuthTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthTokenMultiError) AllErrors() []error { return m }

// AuthTokenValidationError is the validation error returned by
// AuthToken.Validate if the designated constraints aren't met.
type AuthTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthTokenValidationError) ErrorName() string { return "AuthTokenValidationError" }

// Error satisfies the builtin error interface
func (e AuthTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthTokenValidationError{}

// Validate checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReqMultiError, or
// nil if none found.
func (m *RegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := RegisterReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 8 || l > 16 {
		err := RegisterReqValidationError{
			field:  "Password",
			reason: "value length must be between 8 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProof()); l < 4 || l > 16 {
		err := RegisterReqValidationError{
			field:  "Proof",
			reason: "value length must be between 4 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RegisterType

	// no validation rules for Platform

	// no validation rules for Nickname

	// no validation rules for AreaCode

	// no validation rules for ShareCode

	// no validation rules for FaceURL

	if _, ok := v2.Gender_name[int32(m.GetGender())]; !ok {
		err := RegisterReqValidationError{
			field:  "Gender",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Birth

	// no validation rules for Key

	if len(errors) > 0 {
		return RegisterReqMultiError(errors)
	}

	return nil
}

// RegisterReqMultiError is an error wrapping multiple validation errors
// returned by RegisterReq.ValidateAll() if the designated constraints aren't met.
type RegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReqMultiError) AllErrors() []error { return m }

// RegisterReqValidationError is the validation error returned by
// RegisterReq.Validate if the designated constraints aren't met.
type RegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReqValidationError) ErrorName() string { return "RegisterReqValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReqValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := RegisterReplyValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LoginReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReqMultiError, or nil
// if none found.
func (m *LoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := LoginReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProof()); l < 4 || l > 16 {
		err := LoginReqValidationError{
			field:  "Proof",
			reason: "value length must be between 4 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountType

	// no validation rules for ResponseType

	// no validation rules for Platform

	// no validation rules for Node

	// no validation rules for ResNodeInfo

	// no validation rules for Key

	if len(errors) > 0 {
		return LoginReqMultiError(errors)
	}

	return nil
}

// LoginReqMultiError is an error wrapping multiple validation errors returned
// by LoginReq.ValidateAll() if the designated constraints aren't met.
type LoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReqMultiError) AllErrors() []error { return m }

// LoginReqValidationError is the validation error returned by
// LoginReq.Validate if the designated constraints aren't met.
type LoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReqValidationError) ErrorName() string { return "LoginReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReqValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuthToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "AuthToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AuthorizationCode

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on DestructionTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DestructionTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestructionTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestructionTokenReqMultiError, or nil if none found.
func (m *DestructionTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DestructionTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccessToken()) < 1 {
		err := DestructionTokenReqValidationError{
			field:  "AccessToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DestructionTokenReqMultiError(errors)
	}

	return nil
}

// DestructionTokenReqMultiError is an error wrapping multiple validation
// errors returned by DestructionTokenReq.ValidateAll() if the designated
// constraints aren't met.
type DestructionTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestructionTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestructionTokenReqMultiError) AllErrors() []error { return m }

// DestructionTokenReqValidationError is the validation error returned by
// DestructionTokenReq.Validate if the designated constraints aren't met.
type DestructionTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestructionTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestructionTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestructionTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestructionTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestructionTokenReqValidationError) ErrorName() string {
	return "DestructionTokenReqValidationError"
}

// Error satisfies the builtin error interface
func (e DestructionTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestructionTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestructionTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestructionTokenReqValidationError{}

// Validate checks the field values on DestructionTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DestructionTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestructionTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestructionTokenReplyMultiError, or nil if none found.
func (m *DestructionTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DestructionTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DestructionTokenReplyMultiError(errors)
	}

	return nil
}

// DestructionTokenReplyMultiError is an error wrapping multiple validation
// errors returned by DestructionTokenReply.ValidateAll() if the designated
// constraints aren't met.
type DestructionTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestructionTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestructionTokenReplyMultiError) AllErrors() []error { return m }

// DestructionTokenReplyValidationError is the validation error returned by
// DestructionTokenReply.Validate if the designated constraints aren't met.
type DestructionTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestructionTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestructionTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestructionTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestructionTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestructionTokenReplyValidationError) ErrorName() string {
	return "DestructionTokenReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DestructionTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestructionTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestructionTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestructionTokenReplyValidationError{}

// Validate checks the field values on RefTokenReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefTokenReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefTokenReqMultiError, or
// nil if none found.
func (m *RefTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RefTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRefToken()) < 1 {
		err := RefTokenReqValidationError{
			field:  "RefToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResNodeInfo

	// no validation rules for Node

	if len(errors) > 0 {
		return RefTokenReqMultiError(errors)
	}

	return nil
}

// RefTokenReqMultiError is an error wrapping multiple validation errors
// returned by RefTokenReq.ValidateAll() if the designated constraints aren't met.
type RefTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefTokenReqMultiError) AllErrors() []error { return m }

// RefTokenReqValidationError is the validation error returned by
// RefTokenReq.Validate if the designated constraints aren't met.
type RefTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefTokenReqValidationError) ErrorName() string { return "RefTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e RefTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefTokenReqValidationError{}

// Validate checks the field values on RefTokenReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefTokenReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefTokenReplyMultiError, or
// nil if none found.
func (m *RefTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RefTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuthToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefTokenReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefTokenReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefTokenReplyValidationError{
				field:  "AuthToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefTokenReplyValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefTokenReplyValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefTokenReplyValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefTokenReplyMultiError(errors)
	}

	return nil
}

// RefTokenReplyMultiError is an error wrapping multiple validation errors
// returned by RefTokenReply.ValidateAll() if the designated constraints
// aren't met.
type RefTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefTokenReplyMultiError) AllErrors() []error { return m }

// RefTokenReplyValidationError is the validation error returned by
// RefTokenReply.Validate if the designated constraints aren't met.
type RefTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefTokenReplyValidationError) ErrorName() string { return "RefTokenReplyValidationError" }

// Error satisfies the builtin error interface
func (e RefTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefTokenReplyValidationError{}

// Validate checks the field values on VerifyTokenReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VerifyTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VerifyTokenReqMultiError,
// or nil if none found.
func (m *VerifyTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccessToken()) < 1 {
		err := VerifyTokenReqValidationError{
			field:  "AccessToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizeType

	if len(errors) > 0 {
		return VerifyTokenReqMultiError(errors)
	}

	return nil
}

// VerifyTokenReqMultiError is an error wrapping multiple validation errors
// returned by VerifyTokenReq.ValidateAll() if the designated constraints
// aren't met.
type VerifyTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyTokenReqMultiError) AllErrors() []error { return m }

// VerifyTokenReqValidationError is the validation error returned by
// VerifyTokenReq.Validate if the designated constraints aren't met.
type VerifyTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyTokenReqValidationError) ErrorName() string { return "VerifyTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e VerifyTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyTokenReqValidationError{}

// Validate checks the field values on VerifyTokenReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VerifyTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyTokenReplyMultiError, or nil if none found.
func (m *VerifyTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuthToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifyTokenReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifyTokenReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifyTokenReplyValidationError{
				field:  "AuthToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifyTokenReplyMultiError(errors)
	}

	return nil
}

// VerifyTokenReplyMultiError is an error wrapping multiple validation errors
// returned by VerifyTokenReply.ValidateAll() if the designated constraints
// aren't met.
type VerifyTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyTokenReplyMultiError) AllErrors() []error { return m }

// VerifyTokenReplyValidationError is the validation error returned by
// VerifyTokenReply.Validate if the designated constraints aren't met.
type VerifyTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyTokenReplyValidationError) ErrorName() string { return "VerifyTokenReplyValidationError" }

// Error satisfies the builtin error interface
func (e VerifyTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyTokenReplyValidationError{}

// Validate checks the field values on SendCodeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendCodeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendCodeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendCodeReqMultiError, or
// nil if none found.
func (m *SendCodeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendCodeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := SendCodeReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CodeType

	// no validation rules for AreaCode

	if len(errors) > 0 {
		return SendCodeReqMultiError(errors)
	}

	return nil
}

// SendCodeReqMultiError is an error wrapping multiple validation errors
// returned by SendCodeReq.ValidateAll() if the designated constraints aren't met.
type SendCodeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendCodeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendCodeReqMultiError) AllErrors() []error { return m }

// SendCodeReqValidationError is the validation error returned by
// SendCodeReq.Validate if the designated constraints aren't met.
type SendCodeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendCodeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendCodeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendCodeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendCodeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendCodeReqValidationError) ErrorName() string { return "SendCodeReqValidationError" }

// Error satisfies the builtin error interface
func (e SendCodeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendCodeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendCodeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendCodeReqValidationError{}

// Validate checks the field values on SendCodeReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendCodeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendCodeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendCodeReplyMultiError, or
// nil if none found.
func (m *SendCodeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SendCodeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Seconds

	// no validation rules for ExpiresAt

	// no validation rules for Key

	if len(errors) > 0 {
		return SendCodeReplyMultiError(errors)
	}

	return nil
}

// SendCodeReplyMultiError is an error wrapping multiple validation errors
// returned by SendCodeReply.ValidateAll() if the designated constraints
// aren't met.
type SendCodeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendCodeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendCodeReplyMultiError) AllErrors() []error { return m }

// SendCodeReplyValidationError is the validation error returned by
// SendCodeReply.Validate if the designated constraints aren't met.
type SendCodeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendCodeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendCodeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendCodeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendCodeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendCodeReplyValidationError) ErrorName() string { return "SendCodeReplyValidationError" }

// Error satisfies the builtin error interface
func (e SendCodeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendCodeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendCodeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendCodeReplyValidationError{}

// Validate checks the field values on VerifyCodeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VerifyCodeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyCodeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VerifyCodeReqMultiError, or
// nil if none found.
func (m *VerifyCodeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyCodeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := VerifyCodeReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CodeType

	if l := utf8.RuneCountInString(m.GetCode()); l < 4 || l > 8 {
		err := VerifyCodeReqValidationError{
			field:  "Code",
			reason: "value length must be between 4 and 8 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Key

	if len(errors) > 0 {
		return VerifyCodeReqMultiError(errors)
	}

	return nil
}

// VerifyCodeReqMultiError is an error wrapping multiple validation errors
// returned by VerifyCodeReq.ValidateAll() if the designated constraints
// aren't met.
type VerifyCodeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyCodeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyCodeReqMultiError) AllErrors() []error { return m }

// VerifyCodeReqValidationError is the validation error returned by
// VerifyCodeReq.Validate if the designated constraints aren't met.
type VerifyCodeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyCodeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyCodeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyCodeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyCodeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyCodeReqValidationError) ErrorName() string { return "VerifyCodeReqValidationError" }

// Error satisfies the builtin error interface
func (e VerifyCodeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyCodeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyCodeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyCodeReqValidationError{}

// Validate checks the field values on VerifyCodeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VerifyCodeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyCodeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyCodeReplyMultiError, or nil if none found.
func (m *VerifyCodeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyCodeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pass

	if len(errors) > 0 {
		return VerifyCodeReplyMultiError(errors)
	}

	return nil
}

// VerifyCodeReplyMultiError is an error wrapping multiple validation errors
// returned by VerifyCodeReply.ValidateAll() if the designated constraints
// aren't met.
type VerifyCodeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyCodeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyCodeReplyMultiError) AllErrors() []error { return m }

// VerifyCodeReplyValidationError is the validation error returned by
// VerifyCodeReply.Validate if the designated constraints aren't met.
type VerifyCodeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyCodeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyCodeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyCodeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyCodeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyCodeReplyValidationError) ErrorName() string { return "VerifyCodeReplyValidationError" }

// Error satisfies the builtin error interface
func (e VerifyCodeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyCodeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyCodeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyCodeReplyValidationError{}

// Validate checks the field values on UpdatePasswordReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePasswordReqMultiError, or nil if none found.
func (m *UpdatePasswordReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := UpdatePasswordReqValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 8 || l > 16 {
		err := UpdatePasswordReqValidationError{
			field:  "Password",
			reason: "value length must be between 8 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProof()); l < 4 || l > 16 {
		err := UpdatePasswordReqValidationError{
			field:  "Proof",
			reason: "value length must be between 4 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CodeType

	// no validation rules for Account

	// no validation rules for Key

	// no validation rules for NodeId

	if len(errors) > 0 {
		return UpdatePasswordReqMultiError(errors)
	}

	return nil
}

// UpdatePasswordReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePasswordReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePasswordReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordReqMultiError) AllErrors() []error { return m }

// UpdatePasswordReqValidationError is the validation error returned by
// UpdatePasswordReq.Validate if the designated constraints aren't met.
type UpdatePasswordReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordReqValidationError) ErrorName() string {
	return "UpdatePasswordReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordReqValidationError{}

// Validate checks the field values on UpdatePasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePasswordReplyMultiError, or nil if none found.
func (m *UpdatePasswordReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePasswordReplyMultiError(errors)
	}

	return nil
}

// UpdatePasswordReplyMultiError is an error wrapping multiple validation
// errors returned by UpdatePasswordReply.ValidateAll() if the designated
// constraints aren't met.
type UpdatePasswordReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordReplyMultiError) AllErrors() []error { return m }

// UpdatePasswordReplyValidationError is the validation error returned by
// UpdatePasswordReply.Validate if the designated constraints aren't met.
type UpdatePasswordReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordReplyValidationError) ErrorName() string {
	return "UpdatePasswordReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordReplyValidationError{}

// Validate checks the field values on RealNameAuthReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RealNameAuthReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameAuthReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealNameAuthReqMultiError, or nil if none found.
func (m *RealNameAuthReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameAuthReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if utf8.RuneCountInString(m.GetFullName()) < 1 {
		err := RealNameAuthReqValidationError{
			field:  "FullName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPersonId()) < 1 {
		err := RealNameAuthReqValidationError{
			field:  "PersonId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RealPhone

	if len(errors) > 0 {
		return RealNameAuthReqMultiError(errors)
	}

	return nil
}

// RealNameAuthReqMultiError is an error wrapping multiple validation errors
// returned by RealNameAuthReq.ValidateAll() if the designated constraints
// aren't met.
type RealNameAuthReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameAuthReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameAuthReqMultiError) AllErrors() []error { return m }

// RealNameAuthReqValidationError is the validation error returned by
// RealNameAuthReq.Validate if the designated constraints aren't met.
type RealNameAuthReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameAuthReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameAuthReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameAuthReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameAuthReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameAuthReqValidationError) ErrorName() string { return "RealNameAuthReqValidationError" }

// Error satisfies the builtin error interface
func (e RealNameAuthReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameAuthReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameAuthReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameAuthReqValidationError{}

// Validate checks the field values on RealNameAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RealNameAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealNameAuthReplyMultiError, or nil if none found.
func (m *RealNameAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RealNameAuthReplyMultiError(errors)
	}

	return nil
}

// RealNameAuthReplyMultiError is an error wrapping multiple validation errors
// returned by RealNameAuthReply.ValidateAll() if the designated constraints
// aren't met.
type RealNameAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameAuthReplyMultiError) AllErrors() []error { return m }

// RealNameAuthReplyValidationError is the validation error returned by
// RealNameAuthReply.Validate if the designated constraints aren't met.
type RealNameAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameAuthReplyValidationError) ErrorName() string {
	return "RealNameAuthReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RealNameAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameAuthReplyValidationError{}

// Validate checks the field values on SSOLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SSOLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSOLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SSOLoginReqMultiError, or
// nil if none found.
func (m *SSOLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SSOLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := SSOLoginReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	// no validation rules for Platform

	if len(errors) > 0 {
		return SSOLoginReqMultiError(errors)
	}

	return nil
}

// SSOLoginReqMultiError is an error wrapping multiple validation errors
// returned by SSOLoginReq.ValidateAll() if the designated constraints aren't met.
type SSOLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSOLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSOLoginReqMultiError) AllErrors() []error { return m }

// SSOLoginReqValidationError is the validation error returned by
// SSOLoginReq.Validate if the designated constraints aren't met.
type SSOLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSOLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSOLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSOLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSOLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSOLoginReqValidationError) ErrorName() string { return "SSOLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e SSOLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSOLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSOLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSOLoginReqValidationError{}

// Validate checks the field values on SSOLoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SSOLoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSOLoginReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SSOLoginReplyMultiError, or
// nil if none found.
func (m *SSOLoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SSOLoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuthToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SSOLoginReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SSOLoginReplyValidationError{
					field:  "AuthToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SSOLoginReplyValidationError{
				field:  "AuthToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SSOLoginReplyMultiError(errors)
	}

	return nil
}

// SSOLoginReplyMultiError is an error wrapping multiple validation errors
// returned by SSOLoginReply.ValidateAll() if the designated constraints
// aren't met.
type SSOLoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSOLoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSOLoginReplyMultiError) AllErrors() []error { return m }

// SSOLoginReplyValidationError is the validation error returned by
// SSOLoginReply.Validate if the designated constraints aren't met.
type SSOLoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSOLoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSOLoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSOLoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSOLoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSOLoginReplyValidationError) ErrorName() string { return "SSOLoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e SSOLoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSOLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSOLoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSOLoginReplyValidationError{}

// Validate checks the field values on BindingReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BindingReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindingReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BindingReqMultiError, or
// nil if none found.
func (m *BindingReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BindingReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := BindingReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CodeType

	// no validation rules for AreaCode

	if l := utf8.RuneCountInString(m.GetCode()); l < 4 || l > 8 {
		err := BindingReqValidationError{
			field:  "Code",
			reason: "value length must be between 4 and 8 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Key

	if len(errors) > 0 {
		return BindingReqMultiError(errors)
	}

	return nil
}

// BindingReqMultiError is an error wrapping multiple validation errors
// returned by BindingReq.ValidateAll() if the designated constraints aren't met.
type BindingReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingReqMultiError) AllErrors() []error { return m }

// BindingReqValidationError is the validation error returned by
// BindingReq.Validate if the designated constraints aren't met.
type BindingReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingReqValidationError) ErrorName() string { return "BindingReqValidationError" }

// Error satisfies the builtin error interface
func (e BindingReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingReqValidationError{}

// Validate checks the field values on BindingReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BindingReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindingReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BindingReplyMultiError, or
// nil if none found.
func (m *BindingReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BindingReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BindingReplyMultiError(errors)
	}

	return nil
}

// BindingReplyMultiError is an error wrapping multiple validation errors
// returned by BindingReply.ValidateAll() if the designated constraints aren't met.
type BindingReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingReplyMultiError) AllErrors() []error { return m }

// BindingReplyValidationError is the validation error returned by
// BindingReply.Validate if the designated constraints aren't met.
type BindingReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingReplyValidationError) ErrorName() string { return "BindingReplyValidationError" }

// Error satisfies the builtin error interface
func (e BindingReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingReplyValidationError{}
